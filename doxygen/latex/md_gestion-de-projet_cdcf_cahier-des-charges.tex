\subsection*{Presentation du projet}

Ce projet porte sur l\textquotesingle{}émulation du système de la console de jeux \hyperlink{struct_n_e_s}{N\+ES}. C\textquotesingle{}est à dire reproduire son comportement hardware et software de manière logicielle. La console de jeux \hyperlink{struct_n_e_s}{N\+ES} est une console de jeux sortie en 1985 et développée par la société japonaise Nintendo.

\subsection*{Objectifs}


\begin{DoxyItemize}
\item Emuler le fonctionnement de la console \hyperlink{struct_n_e_s}{N\+ES} de Nintendo
\item Être en capacité d\textquotesingle{}émuler la plupart des jeux sous license
\item Développer pour fonctionner sous Linux
\end{DoxyItemize}

\subsection*{Outils de développement}

Nous avons choisi développer notre émulateur à travers un Makefile, de tel manière à ce que chacun puisse utiliser son propre I\+DE (vim, Atom, Code\+Blocks). A l\textquotesingle{}avenir, nous utiliserons C\+Make pour généraliser la compilation et la reprise du projet sur n\textquotesingle{}importe quel I\+DE.

\subsection*{Comment fonctionne la \hyperlink{struct_n_e_s}{N\+ES}}

\subsubsection*{\hyperlink{struct_c_p_u}{C\+PU}}

\paragraph*{Representation de la mémoire}



\paragraph*{Fonctionnement du processeur 6502}

Le processeur est de type 8 bits. Ses registres de travail sont donc aussi de taille 8 bits. Cela implique que c\textquotesingle{}est aussi la taille maximale des données manipulables.

Cependant, le Programme Counter (PC) est lui de taille 16 bits. Le domaine d\textquotesingle{}adressage disponible est ainsi de 64\+Ko.

Il possède en plus un Multi-\/\+Memory \hyperlink{struct_controller}{Controller} (M\+MC) qui permet d\textquotesingle{}adresser plus de mémoire. (Voir partie mémoire).

Le processeur possède un jeu d\textquotesingle{}instruction capable de manipuler les 64 Ko de mémoire et 6 registres.

{\bfseries Registres 8 bits} \+:
\begin{DoxyItemize}
\item {\bfseries \hyperlink{struct_stack}{Stack} register} \+: Garde l\textquotesingle{}adresse du haut de la pile, pile permettant de sauvegarder des données lors de l’exécution d\textquotesingle{}une fonction.
\item {\bfseries Processor Status} \+: Registre de flags, il possède en tout 7 flags car le bit numéro 5 du registre n\textquotesingle{}est pas utilisé.
\begin{DoxyItemize}
\item Bit 0 \+: Carry out (C)
\item Bit 1 \+: Zero flag (Z)
\item Bit 2 \+: Interrupt Disable Flag (I)
\item Bit 3 \+: Decimal mode (D)
\item Bit 5 \+: N/A
\item Bit 6 \+: Break Command (B)
\item Bit 7 \+: Negative Flag (N)
\end{DoxyItemize}
\item {\bfseries Accumulator} \+: Registre de travail principal. Utilisé pour toutes les instructions arithmétiques et logiques.
\item {\bfseries Registre X} \+: Utilisé pour les adressages indexés et le contrôle des boucles.
\item {\bfseries Registre Y} \+: Comparable au registre X mais possède moins de fonctionnalités.
\end{DoxyItemize}

{\bfseries Registres 16 bits}
\begin{DoxyItemize}
\item Program Counter \+: Adressage des 64 Ko de mémoire. Il contient l\textquotesingle{}adresse de la prochaine instruction à exécuter.
\end{DoxyItemize}

\paragraph*{Les modes d\textquotesingle{}adressages}

Le processeur 6502 possède 12 modes d\textquotesingle{}adressage utilisés par les instructions.


\begin{DoxyItemize}
\item Adressage immédiat \+: \#\$??
\item Adressage absolu \+: \$????
\item Adressage page zéro \+: \$??
\item Adressage indirect absolu \+: (\$????)
\item Adressage absolu indexé \+: \$????,X
\item Adressage indexé page zéro \+: \$??,X
\item Adressage indexé indirect \+: (\$??,X)
\item Adressage indirect indexé \+: (\$??),X
\item Adressage relatif \+: \$?? -\/$>$signé
\item Adressage implié \+: transparent dans l\textquotesingle{}instruction
\end{DoxyItemize}

\paragraph*{Les instructions}

Le processeur possède un jeu de 56 mnémoniques (instructions). Certaines peuvent faire l\textquotesingle{}objet de plusieurs modes d\textquotesingle{}adressage.

{\bfseries Exemple de deux instructions}

{\bfseries A\+DC} \+: Flags utilisés \+: N,Z,C,V

Additionne la valeur contenu dans l\textquotesingle{}Accumulator avec l\textquotesingle{}opérande désigné par le mode d\textquotesingle{}adressage et le bit de retenue. Le résultat est ensuite placé dans l\textquotesingle{}Accumulator. Il y a aussi une mise à jour des flags. Pour effectuer une addition vierge, il faut mettre à zéro le bit de retenue (C). Cette instruction peut utiliser 8 modes d\textquotesingle{}adressage différents.

{\bfseries L\+DA} -\/ Load Accumulator \+: Flags Utilisés \+: N,Z

On passe en paramètre une adresse. L\textquotesingle{}opérande situé à cette adresse en mémoire centrale est chargé dans l\textquotesingle{}Accumulator puis la valeur est évaluée pour déterminer les flags N et Z.

\subsubsection*{\hyperlink{struct_p_p_u}{P\+PU}}

La \hyperlink{struct_p_p_u}{P\+PU} (Picture Processing Unit) a pour fonction de gérer l\textquotesingle{}affichage. La résolution des images produites sont de 256x240 pixels. Son fonctionnement est parallèle et indépendant de la \hyperlink{struct_c_p_u}{C\+PU}. Ainsi, la \hyperlink{struct_p_p_u}{P\+PU} possède son propre espace d\textquotesingle{}adressage.

\paragraph*{Frame rendering}

Le rendu des images/frames s\textquotesingle{}exécute à 60 Hz pour une \hyperlink{struct_n_e_s}{N\+ES} N\+T\+SC et 50 Hz pour la version P\+AL. La \hyperlink{struct_p_p_u}{P\+PU} fonctionne avec une fréquence d\textquotesingle{}horloge 3 fois supérieure à celle de la \hyperlink{struct_c_p_u}{C\+PU}, ainsi {\bfseries 3 pixels sont rendus à l\textquotesingle{}écran en un cycle \hyperlink{struct_c_p_u}{C\+PU}}. On appelle scanline le rendu d\textquotesingle{}une ligne de pixels, comprenant également les pixels invisibles nécessaires au timing des signaux composites. Ainsi on décompte 262 scanlines, chacune d\textquotesingle{}entre elles étant composée de 341 pixels. Lorsque la \hyperlink{struct_p_p_u}{P\+PU} a fini de rendre l\textquotesingle{}image visible à l\textquotesingle{}écran, une succession de 20 scanlines prend place, on appelle cet période {\bfseries vertical blank}. C\textquotesingle{}est durant cet période que l\textquotesingle{}on doit écrire dans la mémoire vidéo pour éviter de potentiels artefacts.

\paragraph*{Pattern Tables}

Pour pallier aux contraintes de l\textquotesingle{}époque, les données décrivant les informations à l\textquotesingle{}écran sont grossières \+: on ne stocke pas en brut la couleur d\textquotesingle{}un pixel à des coordonnées précises, à la place, on crée des blocs contenant les informations nécessaires (dessin, couleur) puis on vient les appeler dans une table mémoire pour les afficher à l\textquotesingle{}écran. Un bloc élémentaire est constitué de {\bfseries 8x8 pixels} et est appelé {\bfseries fun pattern}. Ces patterns permettent de décrire le décor (background) et les personnages/objets à l\textquotesingle{}écran (sprites).

La table des patterns est contenue dans une R\+OM (appelé C\+H\+R-\/\+R\+OM) sur le circuit imprimé de la cartouche de jeu. Cette R\+OM est généralement d\textquotesingle{}une taille de 8\+KB, permettant de {\bfseries stocker 512 patterns}. Chaque pattern occupe 16 octets de mémoire, décrivant ainsi les couleurs avec deux bits par pixels, {\bfseries soit 4 couleurs possibles pour sur un pattern} (voir l\textquotesingle{}illustration ci-\/dessous). Nous verrons dans la partie sur les palettes de couleur comment fonctionne le mécanisme de coloriage.



La figure ci-\/dessous illustre le contenu de la table des patterns pour le jeu Super Mario Bros. On retrouve des élements de background comme des sprites.



\paragraph*{Colour Palette}

La \hyperlink{struct_n_e_s}{N\+ES} est capable d\textquotesingle{}afficher {\bfseries 52 couleurs}, cependant, dû aux limitations techniques de l\textquotesingle{}époque, seulement quelques couleurs pourront être affichées sur une frame. L\textquotesingle{}objectif de cette limitation est de limiter l\textquotesingle{}espace mémoire qu\textquotesingle{}occuperont les images. Ainsi, la solution fut de créer {\bfseries des palettes de 4 couleurs} \+: {\bfseries 4 palettes pour le background et 4 autres pour les sprites}. Les éléments affichés à l\textquotesingle{}écran feront référence à une des palettes de couleurs (grâce à un index) afin d\textquotesingle{}être coloriés correctement.

Sur l\textquotesingle{}illustration qui suit, les quatre palettes du haut correspondent aux palettes pour les sprites. On remarque pour chacun d\textquotesingle{}eux que la dernière couleur semble être noire, or en réalité il s\textquotesingle{}agit de {\bfseries la transparence} \+: un pixel possédant cet priorité laisse entrevoir le background. Juste en dessous, on retrouve les palettes pour le background.



\paragraph*{Name Tables}

Le background est constitué {\bfseries d\textquotesingle{}une grille de 32x30 patterns}. En mémoire, on appelle cet grille/tableau une {\bfseries name table}. On associe à cet espace une {\bfseries attribute table}, une table permettant de décrire quelle palette de couleur utiliser pour chaque pattern. L\textquotesingle{}espace d\textquotesingle{}adressage de la \hyperlink{struct_p_p_u}{P\+PU} permet {\bfseries l\textquotesingle{}usage de 4 name tables}, ceci-\/dit, seulement deux sont physiquement présentes sur la \hyperlink{struct_n_e_s}{N\+ES}, les deux autres doivent provenir de la cartouche si nécessaire.

L\textquotesingle{}usage de multiple name tables permet d\textquotesingle{}effectuer du {\bfseries scrolling}, principe utilisé dans les jeux de plateformes pour se déplacer dans un niveau (comme dans Super Mario Bros. par exemple).



En fonction de comment le joueur évolue sur la carte (verticalement ou horizontalement), il est possible d\textquotesingle{}organiser les name tables très précisément avec le principe de \href{https://wiki.nesdev.com/w/index.php/Mirroring}{\tt {\bfseries mirroring}}.

\paragraph*{Object Attribute Memory}

La \hyperlink{struct_n_e_s}{N\+ES} est capable d\textquotesingle{}afficher 64 sprites sur une même frame. Cet caractéristique est toutefois contraintes par la limite de {\bfseries 8 sprites par scanline}. Dans le cas d\textquotesingle{}un overflow de sprite sur une scanline, un bit est levé dans les registres d\textquotesingle{}états de la \hyperlink{struct_p_p_u}{P\+PU}. Les informations sur les sprites affichés à l\textquotesingle{}écran sont à écrire dans l\textquotesingle{}Object Attribute Memory (O\+AM) ou aussi appelé S\+P\+R-\/\+R\+AM (sprite R\+AM). Cet espace mémoire est {\bfseries remis à zéro à chaque fois qu\textquotesingle{}une image a été rendue à l\textquotesingle{}écran}, ainsi, le jeu doit réécrire à chaque rendu pour que les sprites puissent être ré-\/affichés à l\textquotesingle{}écran.

Chaque sprite est représenté par 4 octets dans l\textquotesingle{}O\+AM \+:
\begin{DoxyItemize}
\item Position sur l\textquotesingle{}axe Y (bytes 0)
\item Index du pattern à afficher (bytes 1)
\item Attribut du sprite (bytes 2)
\begin{DoxyItemize}
\item Palette de couleur utilisée
\item Priorité du sprite vis-\/à-\/vis du background
\item Mirroir horizontal
\item Mirroir vertical
\end{DoxyItemize}
\item Position sur l\textquotesingle{}axe X (bytes 3)
\end{DoxyItemize}

La priorité entre les différents sprites est gérée par l\textquotesingle{}ordre dans lequel les sprites sont écris dans l\textquotesingle{}O\+AM.

L\textquotesingle{}O\+AM peut être intégralement {\bfseries écrit en D\+MA} depuis le \hyperlink{struct_c_p_u}{C\+PU}, généralement après chaque vertical blank, dans le handler de l\textquotesingle{}interruption N\+MI.

\subsubsection*{A\+PU}

L\textquotesingle{}A\+PU est l\textquotesingle{}unité de traitement sonore de la \hyperlink{struct_n_e_s}{N\+ES}. Cette unité est intégrée à la puce 6502 et communique avec la \hyperlink{struct_c_p_u}{C\+PU} par l\textquotesingle{}intermédiaire de registres. La \hyperlink{struct_c_p_u}{C\+PU} va donc écrire les informations que l\textquotesingle{}A\+PU interprètera et traduira en signal sonore.

Cette unité possède 5 canaux sonores\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Nom }&\PBS\centering \textbf{ Type de signal }&\textbf{ Utilisation principale  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\PBS\centering \textbf{ Nom }&\PBS\centering \textbf{ Type de signal }&\textbf{ Utilisation principale  }\\\cline{1-3}
\endhead
\PBS\centering Pulse 1 &\PBS\centering Carré &Mélodie 1 \\\cline{1-3}
\PBS\centering Pulse 2 &\PBS\centering Carré &Mélodie 2 \\\cline{1-3}
\PBS\centering Triangle &\PBS\centering Triangle &Basse \\\cline{1-3}
\PBS\centering Noise &\PBS\centering Aléatoire &Percussions et effets divers \\\cline{1-3}
\PBS\centering D\+MC &\PBS\centering Samples pré-\/enregistrés &Sons pré-\/enregistrés (bonus, pièces, ...) \\\cline{1-3}
\end{longtabu}
À chaque canal correspond des registres décrivant les différentes caractéristiques du son à produire. Ces registres occupent les adresses {\itshape 0x4000} à {\itshape 0x4017}\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Registres }&\PBS\centering \textbf{ Canal  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Registres }&\PBS\centering \textbf{ Canal  }\\\cline{1-2}
\endhead
{\bfseries 0x4000 -\/ 0x4003} &\PBS\centering Pulse 1 \\\cline{1-2}
{\bfseries 0x4004 -\/ 0x4007} &\PBS\centering Pulse 2 \\\cline{1-2}
{\bfseries 0x4008 -\/ 0x400B} &\PBS\centering Triangle \\\cline{1-2}
{\bfseries 0x400C -\/ 0x400F} &\PBS\centering Noise \\\cline{1-2}
{\bfseries 0x4010 -\/ 0x4013} &\PBS\centering D\+MC \\\cline{1-2}
{\bfseries 0x4015} &\PBS\centering Tous \\\cline{1-2}
{\bfseries 0x4017} &\PBS\centering Tous \\\cline{1-2}
\end{longtabu}
Le registre {\itshape 0x4015} régit l\textquotesingle{}activation ou non des différents canaux. Le registre {\itshape 0x4017} régit le mode du séquenceur (mode 4 état ou mode 5 états, il ne sera pas détaillé ici).

Afin d\textquotesingle{}observer en détail les valeurs dans ces registres, prennons pour exemple, le premier registre utilisé par le canal {\itshape Pulse 1} \+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Adresse }&\textbf{ Canal }&\textbf{ Description  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Adresse }&\textbf{ Canal }&\textbf{ Description  }\\\cline{1-3}
\endhead
{\itshape 0x4000} &Pulse 1 &D\+D\+LC V\+V\+VV \\\cline{1-3}
\end{longtabu}

\begin{DoxyItemize}
\item {\bfseries DD} \+: Duty cycle (rapport cyclique) Décrit le rapport cyclique du signal carré. Il peut prendre 4 valeurs \+:
\end{DoxyItemize}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ D }&\textbf{ D }&\PBS\centering \textbf{ Rapport Cyclique }&\PBS\centering \textbf{ Représentation \char`\"{}graphique\char`\"{}  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ D }&\textbf{ D }&\PBS\centering \textbf{ Rapport Cyclique }&\PBS\centering \textbf{ Représentation \char`\"{}graphique\char`\"{}  }\\\cline{1-4}
\endhead
0 &0 &\PBS\centering 12.\+5 \% &\PBS\centering \+\_\+ -\/‑ \+\_\+ \+\_\+ \+\_\+ \+\_\+ \+\_\+ \+\_\+ \\\cline{1-4}
0 &1 &\PBS\centering 25 \% &\PBS\centering \+\_\+ -\/‑-- \+\_\+ \+\_\+ \+\_\+ \+\_\+ \+\_\+ \\\cline{1-4}
1 &0 &\PBS\centering 50 \% &\PBS\centering \+\_\+ -\/-\/-\/-\/-\/--- \+\_\+ \+\_\+ \+\_\+ \\\cline{1-4}
1 &1 &\PBS\centering 25 \% inversé &\PBS\centering -- \+\_\+ \+\_\+ -\/-\/-\/-\/-\/-\/-\/--- \\\cline{1-4}
\end{longtabu}

\begin{DoxyItemize}
\item {\bfseries L \+: Length Counter} Ce bit régit l\textquotesingle{}arrêt (1) ou non (0) du \char`\"{}length counter\char`\"{} permettant la gestion automatique de la durée des notes. Lorsque le bit {\bfseries L} est à l\textquotesingle{}état 0, le compteur effectue une fonction de décomptage depuis une valeur stockée dans le registe {\itshape 0x4003}. Lorsque le compteur atteint 0, la note est stoppée.
\item {\bfseries C \+: Constant volume} Lorsque ce bit est à l\textquotesingle{}état 1, l\textquotesingle{}A\+PU utilise la valeur constante {\itshape V\+V\+VV} comme valeur de volume pour le canal. Sinon, le volume est géré par l\textquotesingle{}enveloppe de volume (outil permettant d\textquotesingle{}effectuer des modifications sur le volume que nous ne détaillerons pas ici)
\item {\bfseries V\+V\+VV \+: Volume} Valeur utilisée comme valeur de volume constant si le bit {\bfseries C} est à 1.
\end{DoxyItemize}

Des informations complémentaires sur l\textquotesingle{}A\+PU sont disponibles \href{http://wiki.nesdev.com/w/index.php/APU}{\tt {\bfseries ici}}.

\subsubsection*{\hyperlink{struct_mapper}{Mapper} mémoire}

La \hyperlink{struct_n_e_s}{N\+ES} a besoin de {\bfseries charger le contenu du jeu} dans la {\bfseries mémoire de la \hyperlink{struct_c_p_u}{C\+PU}} (cf paragraphe sur la \hyperlink{struct_c_p_u}{C\+PU}). De ce fait, elle réserve 32\+KB pour la mémoire programme, ou P\+R\+G-\/\+R\+OM, entre {\itshape 0x8000} et {\itshape 0x\+F\+F\+FF}. De plus, la \hyperlink{struct_p_p_u}{P\+PU} réserve {\itshape 8\+KB} de R\+OM appelée C\+H\+R-\/\+R\+OM, pour stocker des éléments graphiques du jeu.

Une cartouche de jeux contenant {\itshape 16\+KB} de programme est chargée deux fois \+: à {\itshape 0x8000} et à {\itshape 0x\+C000}, et une cartouche contenant {\itshape 32\+KB} de programme est chargée sur la totalité de la plage réservée. Cette taille suffisait pour les premiers jeux, mais très vite les jeux étaient réalisés sur plusieurs banques de {\itshape 32\+KB}.

La \hyperlink{struct_n_e_s}{N\+ES} utilise donc du hardware intégré à la cartouche et appelé M\+MC (Memory Management Chip), ou mapper mémoire, afin de savoir quelle partie de la cartouche doit être chargée dans la P\+R\+G-\/\+R\+OM. Lorsque le système a besoin d\textquotesingle{}accéder à des données situées {\bfseries hors de la banque de donnée actuellement chargée}, le programme demande à la M\+CC de charger la banque de donnée d\textquotesingle{}intérêt dans la P\+R\+G-\/\+R\+OM, effaçant ainsi les données chargées.

Voici une courte description des M\+MC basiques \+:
\begin{DoxyItemize}
\item {\bfseries N\+R\+OM} (mapper 0) \+: Le premier mapper, développé par Nintendo. Les banques de données sont fixes et le chargement des données est celui décrit au paragraphe 2. Il n\textquotesingle{}existe pas de gestion du chargement de donnée dans la R\+OM de la \hyperlink{struct_p_p_u}{P\+PU}.
\item {\bfseries U\+N\+R\+OM} (mapper 2)\+: Également développé par Nintendo et utilisé pour des jeux comme Mega man ou Castlevania, qui permet de choisir la banque de donnée chargée sur les premiers {\itshape 16\+KB} et fixe les {\itshape 16\+KB} de fin à la dernière banque de données.
\item {\bfseries M\+M\+C1} (mapper 1) \+: \hyperlink{struct_mapper}{Mapper} très utilisé, notamment pour The Legend of Zelda. Il offre une grande flexibilité sur la P\+R\+G-\/\+R\+OM et permet de charger la C\+H\+R-\/\+R\+OM.
\end{DoxyItemize}

Il en existe plus d\textquotesingle{}une centaine.

\subsection*{Spécificités de l\textquotesingle{}émulateur}

\subsubsection*{Format des fichiers i\+N\+ES}

Le format de fichier i\+N\+ES (extension $\ast$$\ast$.nes$\ast$$\ast$) est très répandue pour le stockage des données des cartouches de jeux \hyperlink{struct_n_e_s}{N\+ES}. Le fichier binaire est constitué d\textquotesingle{}un header (occupant 16 octets) décrivant les caractéristiques de la cartouche (mapper utilisé et taille des mémoires). Ce header est suivi par la mémoire programme (P\+R\+G-\/\+R\+OM, multiple de 16\+KB) puis la mémoire des patterns (C\+H\+R-\/\+R\+OM, multiple de 8\+KB).

\subsubsection*{Types d\textquotesingle{}émulation}

Il existe différentes méthodes pour émuler un support. Dans le cas de la \hyperlink{struct_n_e_s}{N\+ES}, chaque composant (\hyperlink{struct_c_p_u}{C\+PU}, \hyperlink{struct_p_p_u}{P\+PU}, \hyperlink{struct_mapper}{Mapper}) fonctionne en parallèle, ce qui implique une quantité importante de données à traiter. La plupart des émulateurs développés au début de l\textquotesingle{}an 2000 devait faire en sorte d\textquotesingle{}être optimisés au mieux pour ne pas être limités par le processeur de la machine. Ainsi, l\textquotesingle{}une des techniques utilisées était la {\bfseries prédiction}, une méthode permettant de prédire l\textquotesingle{}usage de tels ou tels composants et ne l’exécuter seulement lorsque c\textquotesingle{}est nécessaire. Aujourd\textquotesingle{}hui, nos processeurs n\textquotesingle{}ont rien à envier à l\textquotesingle{}ancienne génération, ces problématiques ne sont donc plus de l\textquotesingle{}ordre du jour et les émulateurs peuvent se permettre d\textquotesingle{}être {\bfseries précis (accurate)}. On entend par précis le fait d’exécuter les composants à chaque instant de l\textquotesingle{}émulation, ce qui rapproche du fonctionnement machine.

Dans notre cas, nous avons choisi de concevoir un {\bfseries émulateur précis} puisque aujourd\textquotesingle{}hui la quasi totalité des ordinateurs sont capables de gérer un tel processus et parce que la prédiction nous aurais demandé un temps de développent bien plus élevé.

\subsubsection*{Fonctionnalités des émulateurs}

Voici une liste non-\/exhaustive de fonctionnalités que l\textquotesingle{}on retrouve sur les émulateurs \hyperlink{struct_n_e_s}{N\+ES} \+:


\begin{DoxyItemize}
\item {\bfseries Save} \+: permet de sauvegarder le contexte d\textquotesingle{}exécution de la machine pour reprendre la progression de son jeu plus tard
\item {\bfseries Movie/\+Tool-\/assisted speedrun} \+: permet de sauvegarder une série d\textquotesingle{}événement pouvant être re-\/exécutés plus tard
\item {\bfseries Pause/\+Resume} \+: stopper/reprendre l\textquotesingle{}exécution de son jeu
\item {\bfseries Speed x} \+: accélérer l\textquotesingle{}exécution de son jeu, pouvant être utile pendant des scènes de dialogues
\item {\bfseries Rescale} \+: agrandir l\textquotesingle{}affichage pour avoir un meilleur confort visuel
\item {\bfseries Configuration des touches claviers} \+: choisir ses touches claviers à associer aux contrôles de la \hyperlink{struct_n_e_s}{N\+ES}
\end{DoxyItemize}

\subsection*{Exigences}


\begin{DoxyItemize}
\item Se rapprocher au plus du fonctionnement hardware de la \hyperlink{struct_n_e_s}{N\+ES} (émulation précise)
\item Développer quelques mappers (deux ou trois)
\item Avoir des performances graphiques fluides (N\+T\+SC -\/ 60 F\+PS)
\item Interface de gestion (choix des R\+O\+Ms, raccourcis clavier, paramètres graphiques)
\begin{DoxyItemize}
\item Pouvoir mettre à l\textquotesingle{}échelle l\textquotesingle{}affichage (proportionnel)
\item Pouvoir enregistrer le contexte d\textquotesingle{}exécution d\textquotesingle{}un jeu pour sauvegarder sa partie
\item Pouvoir mettre en pause le jeu
\end{DoxyItemize}
\item (Optionnel) Développement de l\textquotesingle{}A\+PU (moteur sonore)
\end{DoxyItemize}

\subsection*{Versions}

\subsubsection*{V0}


\begin{DoxyItemize}
\item Émuler l\textquotesingle{}ensemble \hyperlink{struct_c_p_u}{C\+PU} et \hyperlink{struct_p_p_u}{P\+PU}
\item Interagir avec le jeu via les touches du claviers
\item Chargement des R\+O\+Ms via le terminal
\item Développement d\textquotesingle{}un seul mapper (N\+R\+OM)
\end{DoxyItemize}

\subsubsection*{V1}


\begin{DoxyItemize}
\item Développement de plusieurs mappers (M\+M\+C1, M\+M\+C3 et/ou U\+R\+OM)
\item Interface de gestion \+:
\begin{DoxyItemize}
\item Chargement des R\+O\+Ms
\item Configuration des touches
\item Rescale de l\textquotesingle{}image
\item Chargement/\+Sauvegarde du contexte et pause 
\end{DoxyItemize}
\end{DoxyItemize}
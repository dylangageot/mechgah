<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NES Emulator: Emulateur NES</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NES Emulator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Emulateur <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Presentation du projet</h2>
<p>Ce projet porte sur l'émulation du système de la console de jeux <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a>. C'est à dire reproduire son comportement hardware et software de manière logicielle. La console de jeux <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a> est une console de jeux sortie en 1985 et développée par la société japonaise Nintendo.</p>
<h2>Objectifs</h2>
<ul>
<li>Emuler le fonctionnement de la console <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a> de Nintendo</li>
<li>Être en capacité d'émuler la plupart des jeux sous license</li>
<li>Développer pour fonctionner sous Linux</li>
</ul>
<h2>Outils de développement</h2>
<p>Nous avons choisi développer notre émulateur à travers un Makefile, de tel manière à ce que chacun puisse utiliser son propre IDE (vim, Atom, CodeBlocks). A l'avenir, nous utiliserons CMake pour généraliser la compilation et la reprise du projet sur n'importe quel IDE.</p>
<h2>Comment fonctionne la <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a></h2>
<h3><a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a></h3>
<h4>Representation de la mémoire</h4>
<div class="image">
<img src="https://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/s2009/bhp7_teg25/bhp7_teg25/index_files/image012.jpg" alt="Representation-memoire"/>
</div>
<h4>Fonctionnement du processeur 6502</h4>
<p>Le processeur est de type 8 bits. Ses registres de travail sont donc aussi de taille 8 bits. Cela implique que c'est aussi la taille maximale des données manipulables.</p>
<p>Cependant, le Programme Counter (PC) est lui de taille 16 bits. Le domaine d'adressage disponible est ainsi de 64Ko.</p>
<p>Il possède en plus un Multi-Memory <a class="el" href="struct_controller.html" title="Holds necessary variables for the controller emulation to work. Only support the standard joypads...">Controller</a> (MMC) qui permet d'adresser plus de mémoire. (Voir partie mémoire).</p>
<p>Le processeur possède un jeu d'instruction capable de manipuler les 64 Ko de mémoire et 6 registres.</p>
<p><b>Registres 8 bits</b> :</p><ul>
<li><b><a class="el" href="struct_stack.html" title="Hold stack data and capacity information. ">Stack</a> register</b> : Garde l'adresse du haut de la pile, pile permettant de sauvegarder des données lors de l’exécution d'une fonction.</li>
<li><b>Processor Status</b> : Registre de flags, il possède en tout 7 flags car le bit numéro 5 du registre n'est pas utilisé.<ul>
<li>Bit 0 : Carry out (C)</li>
<li>Bit 1 : Zero flag (Z)</li>
<li>Bit 2 : Interrupt Disable Flag (I)</li>
<li>Bit 3 : Decimal mode (D)</li>
<li>Bit 5 : N/A</li>
<li>Bit 6 : Break Command (B)</li>
<li>Bit 7 : Negative Flag (N)</li>
</ul>
</li>
<li><b>Accumulator</b> : Registre de travail principal. Utilisé pour toutes les instructions arithmétiques et logiques.</li>
<li><b>Registre X</b> : Utilisé pour les adressages indexés et le contrôle des boucles.</li>
<li><b>Registre Y</b> : Comparable au registre X mais possède moins de fonctionnalités.</li>
</ul>
<p><b>Registres 16 bits</b></p><ul>
<li>Program Counter : Adressage des 64 Ko de mémoire. Il contient l'adresse de la prochaine instruction à exécuter.</li>
</ul>
<h4>Les modes d'adressages</h4>
<p>Le processeur 6502 possède 12 modes d'adressage utilisés par les instructions.</p>
<ul>
<li>Adressage immédiat : #$??</li>
<li>Adressage absolu : $????</li>
<li>Adressage page zéro : $??</li>
<li>Adressage indirect absolu : ($????)</li>
<li>Adressage absolu indexé : $????,X</li>
<li>Adressage indexé page zéro : $??,X</li>
<li>Adressage indexé indirect : ($??,X)</li>
<li>Adressage indirect indexé : ($??),X</li>
<li>Adressage relatif : $?? -&gt;signé</li>
<li>Adressage implié : transparent dans l'instruction</li>
</ul>
<h4>Les instructions</h4>
<p>Le processeur possède un jeu de 56 mnémoniques (instructions). Certaines peuvent faire l'objet de plusieurs modes d'adressage.</p>
<p><b>Exemple de deux instructions</b></p>
<p><b>ADC</b> : Flags utilisés : N,Z,C,V</p>
<p>Additionne la valeur contenu dans l'Accumulator avec l'opérande désigné par le mode d'adressage et le bit de retenue. Le résultat est ensuite placé dans l'Accumulator. Il y a aussi une mise à jour des flags. Pour effectuer une addition vierge, il faut mettre à zéro le bit de retenue (C). Cette instruction peut utiliser 8 modes d'adressage différents.</p>
<p><b>LDA</b> - Load Accumulator : Flags Utilisés : N,Z</p>
<p>On passe en paramètre une adresse. L'opérande situé à cette adresse en mémoire centrale est chargé dans l'Accumulator puis la valeur est évaluée pour déterminer les flags N et Z.</p>
<h3><a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a></h3>
<p>La <a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a> (Picture Processing Unit) a pour fonction de gérer l'affichage. La résolution des images produites sont de 256x240 pixels. Son fonctionnement est parallèle et indépendant de la <a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a>. Ainsi, la <a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a> possède son propre espace d'adressage.</p>
<h4>Frame rendering</h4>
<p>Le rendu des images/frames s'exécute à 60 Hz pour une <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a> NTSC et 50 Hz pour la version PAL. La <a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a> fonctionne avec une fréquence d'horloge 3 fois supérieure à celle de la <a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a>, ainsi <b>3 pixels sont rendus à l'écran en un cycle <a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a></b>. On appelle scanline le rendu d'une ligne de pixels, comprenant également les pixels invisibles nécessaires au timing des signaux composites. Ainsi on décompte 262 scanlines, chacune d'entre elles étant composée de 341 pixels. Lorsque la <a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a> a fini de rendre l'image visible à l'écran, une succession de 20 scanlines prend place, on appelle cet période <b>vertical blank</b>. C'est durant cet période que l'on doit écrire dans la mémoire vidéo pour éviter de potentiels artefacts.</p>
<h4>Pattern Tables</h4>
<p>Pour pallier aux contraintes de l'époque, les données décrivant les informations à l'écran sont grossières : on ne stocke pas en brut la couleur d'un pixel à des coordonnées précises, à la place, on crée des blocs contenant les informations nécessaires (dessin, couleur) puis on vient les appeler dans une table mémoire pour les afficher à l'écran. Un bloc élémentaire est constitué de <b>8x8 pixels</b> et est appelé <b>fun pattern</b>. Ces patterns permettent de décrire le décor (background) et les personnages/objets à l'écran (sprites).</p>
<p>La table des patterns est contenue dans une ROM (appelé CHR-ROM) sur le circuit imprimé de la cartouche de jeu. Cette ROM est généralement d'une taille de 8KB, permettant de <b>stocker 512 patterns</b>. Chaque pattern occupe 16 octets de mémoire, décrivant ainsi les couleurs avec deux bits par pixels, <b>soit 4 couleurs possibles pour sur un pattern</b> (voir l'illustration ci-dessous). Nous verrons dans la partie sur les palettes de couleur comment fonctionne le mécanisme de coloriage.</p>
<div class="image">
<img src="https://s3.amazonaws.com/n3s/chr.png" alt="pattern-pixel-color"/>
</div>
<p>La figure ci-dessous illustre le contenu de la table des patterns pour le jeu Super Mario Bros. On retrouve des élements de background comme des sprites.</p>
<div class="image">
<img src="https://s3.amazonaws.com/n3s/patterntable.png" alt="pattern-table"/>
</div>
<h4>Colour Palette</h4>
<p>La <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a> est capable d'afficher <b>52 couleurs</b>, cependant, dû aux limitations techniques de l'époque, seulement quelques couleurs pourront être affichées sur une frame. L'objectif de cette limitation est de limiter l'espace mémoire qu'occuperont les images. Ainsi, la solution fut de créer <b>des palettes de 4 couleurs</b> : <b>4 palettes pour le background et 4 autres pour les sprites</b>. Les éléments affichés à l'écran feront référence à une des palettes de couleurs (grâce à un index) afin d'être coloriés correctement.</p>
<p>Sur l'illustration qui suit, les quatre palettes du haut correspondent aux palettes pour les sprites. On remarque pour chacun d'eux que la dernière couleur semble être noire, or en réalité il s'agit de <b>la transparence</b> : un pixel possédant cet priorité laisse entrevoir le background. Juste en dessous, on retrouve les palettes pour le background.</p>
<div class="image">
<img src="https://s3.amazonaws.com/n3s/palettes.png" alt="color-palette"/>
</div>
<h4>Name Tables</h4>
<p>Le background est constitué <b>d'une grille de 32x30 patterns</b>. En mémoire, on appelle cet grille/tableau une <b>name table</b>. On associe à cet espace une <b>attribute table</b>, une table permettant de décrire quelle palette de couleur utiliser pour chaque pattern. L'espace d'adressage de la <a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a> permet <b>l'usage de 4 name tables</b>, ceci-dit, seulement deux sont physiquement présentes sur la <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a>, les deux autres doivent provenir de la cartouche si nécessaire.</p>
<p>L'usage de multiple name tables permet d'effectuer du <b>scrolling</b>, principe utilisé dans les jeux de plateformes pour se déplacer dans un niveau (comme dans Super Mario Bros. par exemple).</p>
<div class="image">
<img src="https://wiki.nesdev.com/w/images/a/ae/SMB1_scrolling_seam.gif" alt="nametable-scrolling"/>
</div>
<p>En fonction de comment le joueur évolue sur la carte (verticalement ou horizontalement), il est possible d'organiser les name tables très précisément avec le principe de <a href="https://wiki.nesdev.com/w/index.php/Mirroring"><b>mirroring</b></a>.</p>
<h4>Object Attribute Memory</h4>
<p>La <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a> est capable d'afficher 64 sprites sur une même frame. Cet caractéristique est toutefois contraintes par la limite de <b>8 sprites par scanline</b>. Dans le cas d'un overflow de sprite sur une scanline, un bit est levé dans les registres d'états de la <a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a>. Les informations sur les sprites affichés à l'écran sont à écrire dans l'Object Attribute Memory (OAM) ou aussi appelé SPR-RAM (sprite RAM). Cet espace mémoire est <b>remis à zéro à chaque fois qu'une image a été rendue à l'écran</b>, ainsi, le jeu doit réécrire à chaque rendu pour que les sprites puissent être ré-affichés à l'écran.</p>
<p>Chaque sprite est représenté par 4 octets dans l'OAM :</p><ul>
<li>Position sur l'axe Y (bytes 0)</li>
<li>Index du pattern à afficher (bytes 1)</li>
<li>Attribut du sprite (bytes 2)<ul>
<li>Palette de couleur utilisée</li>
<li>Priorité du sprite vis-à-vis du background</li>
<li>Mirroir horizontal</li>
<li>Mirroir vertical</li>
</ul>
</li>
<li>Position sur l'axe X (bytes 3)</li>
</ul>
<p>La priorité entre les différents sprites est gérée par l'ordre dans lequel les sprites sont écris dans l'OAM.</p>
<p>L'OAM peut être intégralement <b>écrit en DMA</b> depuis le <a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a>, généralement après chaque vertical blank, dans le handler de l'interruption NMI.</p>
<h3>APU</h3>
<p>L'APU est l'unité de traitement sonore de la <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a>. Cette unité est intégrée à la puce 6502 et communique avec la <a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a> par l'intermédiaire de registres. La <a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a> va donc écrire les informations que l'APU interprètera et traduira en signal sonore.</p>
<p>Cette unité possède 5 canaux sonores:</p>
<table class="doxtable">
<tr>
<th align="center">Nom </th><th align="center">Type de signal </th><th align="left">Utilisation principale  </th></tr>
<tr>
<td align="center">Pulse 1 </td><td align="center">Carré </td><td align="left">Mélodie 1 </td></tr>
<tr>
<td align="center">Pulse 2 </td><td align="center">Carré </td><td align="left">Mélodie 2 </td></tr>
<tr>
<td align="center">Triangle </td><td align="center">Triangle </td><td align="left">Basse </td></tr>
<tr>
<td align="center">Noise </td><td align="center">Aléatoire </td><td align="left">Percussions et effets divers </td></tr>
<tr>
<td align="center">DMC </td><td align="center">Samples pré-enregistrés </td><td align="left">Sons pré-enregistrés (bonus, pièces, ...) </td></tr>
</table>
<p>À chaque canal correspond des registres décrivant les différentes caractéristiques du son à produire. Ces registres occupent les adresses <em>0x4000</em> à <em>0x4017</em>:</p>
<table class="doxtable">
<tr>
<th align="left">Registres </th><th align="center">Canal  </th></tr>
<tr>
<td align="left"><b>0x4000 - 0x4003</b> </td><td align="center">Pulse 1 </td></tr>
<tr>
<td align="left"><b>0x4004 - 0x4007</b> </td><td align="center">Pulse 2 </td></tr>
<tr>
<td align="left"><b>0x4008 - 0x400B</b> </td><td align="center">Triangle </td></tr>
<tr>
<td align="left"><b>0x400C - 0x400F</b> </td><td align="center">Noise </td></tr>
<tr>
<td align="left"><b>0x4010 - 0x4013</b> </td><td align="center">DMC </td></tr>
<tr>
<td align="left"><b>0x4015</b> </td><td align="center">Tous </td></tr>
<tr>
<td align="left"><b>0x4017</b> </td><td align="center">Tous </td></tr>
</table>
<p>Le registre <em>0x4015</em> régit l'activation ou non des différents canaux. Le registre <em>0x4017</em> régit le mode du séquenceur (mode 4 état ou mode 5 états, il ne sera pas détaillé ici).</p>
<p>Afin d'observer en détail les valeurs dans ces registres, prennons pour exemple, le premier registre utilisé par le canal <em>Pulse 1</em> :</p>
<table class="doxtable">
<tr>
<th align="left">Adresse </th><th align="left">Canal </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><em>0x4000</em> </td><td align="left">Pulse 1 </td><td align="left">DDLC VVVV </td></tr>
</table>
<ul>
<li><b>DD</b> : Duty cycle (rapport cyclique) Décrit le rapport cyclique du signal carré. Il peut prendre 4 valeurs :</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">D </th><th align="left">D </th><th align="center">Rapport Cyclique </th><th align="center">Représentation "graphique"  </th></tr>
<tr>
<td align="left">0 </td><td align="left">0 </td><td align="center">12.5 % </td><td align="center">_ -‑ _ _ _ _ _ _ </td></tr>
<tr>
<td align="left">0 </td><td align="left">1 </td><td align="center">25 % </td><td align="center">_ -‑&ndash; _ _ _ _ _ </td></tr>
<tr>
<td align="left">1 </td><td align="left">0 </td><td align="center">50 % </td><td align="center">_ -----&mdash; _ _ _ </td></tr>
<tr>
<td align="left">1 </td><td align="left">1 </td><td align="center">25 % inversé </td><td align="center">&ndash; _ _ -------&mdash; </td></tr>
</table>
<ul>
<li><b>L : Length Counter</b> Ce bit régit l'arrêt (1) ou non (0) du "length counter" permettant la gestion automatique de la durée des notes. Lorsque le bit <b>L</b> est à l'état 0, le compteur effectue une fonction de décomptage depuis une valeur stockée dans le registe <em>0x4003</em>. Lorsque le compteur atteint 0, la note est stoppée.</li>
<li><b>C : Constant volume</b> Lorsque ce bit est à l'état 1, l'APU utilise la valeur constante <em>VVVV</em> comme valeur de volume pour le canal. Sinon, le volume est géré par l'enveloppe de volume (outil permettant d'effectuer des modifications sur le volume que nous ne détaillerons pas ici)</li>
<li><b>VVVV : Volume</b> Valeur utilisée comme valeur de volume constant si le bit <b>C</b> est à 1.</li>
</ul>
<p>Des informations complémentaires sur l'APU sont disponibles <a href="http://wiki.nesdev.com/w/index.php/APU"><b>ici</b></a>.</p>
<h3><a class="el" href="struct_mapper.html" title="Generic structure to hold mapper. ">Mapper</a> mémoire</h3>
<p>La <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a> a besoin de <b>charger le contenu du jeu</b> dans la <b>mémoire de la <a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a></b> (cf paragraphe sur la <a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a>). De ce fait, elle réserve 32KB pour la mémoire programme, ou PRG-ROM, entre <em>0x8000</em> et <em>0xFFFF</em>. De plus, la <a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a> réserve <em>8KB</em> de ROM appelée CHR-ROM, pour stocker des éléments graphiques du jeu.</p>
<p>Une cartouche de jeux contenant <em>16KB</em> de programme est chargée deux fois : à <em>0x8000</em> et à <em>0xC000</em>, et une cartouche contenant <em>32KB</em> de programme est chargée sur la totalité de la plage réservée. Cette taille suffisait pour les premiers jeux, mais très vite les jeux étaient réalisés sur plusieurs banques de <em>32KB</em>.</p>
<p>La <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a> utilise donc du hardware intégré à la cartouche et appelé MMC (Memory Management Chip), ou mapper mémoire, afin de savoir quelle partie de la cartouche doit être chargée dans la PRG-ROM. Lorsque le système a besoin d'accéder à des données situées <b>hors de la banque de donnée actuellement chargée</b>, le programme demande à la MCC de charger la banque de donnée d'intérêt dans la PRG-ROM, effaçant ainsi les données chargées.</p>
<p>Voici une courte description des MMC basiques :</p><ul>
<li><b>NROM</b> (mapper 0) : Le premier mapper, développé par Nintendo. Les banques de données sont fixes et le chargement des données est celui décrit au paragraphe 2. Il n'existe pas de gestion du chargement de donnée dans la ROM de la <a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a>.</li>
<li><b>UNROM</b> (mapper 2): Également développé par Nintendo et utilisé pour des jeux comme Mega man ou Castlevania, qui permet de choisir la banque de donnée chargée sur les premiers <em>16KB</em> et fixe les <em>16KB</em> de fin à la dernière banque de données.</li>
<li><b>MMC1</b> (mapper 1) : <a class="el" href="struct_mapper.html" title="Generic structure to hold mapper. ">Mapper</a> très utilisé, notamment pour The Legend of Zelda. Il offre une grande flexibilité sur la PRG-ROM et permet de charger la CHR-ROM.</li>
</ul>
<p>Il en existe plus d'une centaine.</p>
<h2>Spécificités de l'émulateur</h2>
<h3>Format des fichiers iNES</h3>
<p>Le format de fichier iNES (extension **.nes**) est très répandue pour le stockage des données des cartouches de jeux <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a>. Le fichier binaire est constitué d'un header (occupant 16 octets) décrivant les caractéristiques de la cartouche (mapper utilisé et taille des mémoires). Ce header est suivi par la mémoire programme (PRG-ROM, multiple de 16KB) puis la mémoire des patterns (CHR-ROM, multiple de 8KB).</p>
<h3>Types d'émulation</h3>
<p>Il existe différentes méthodes pour émuler un support. Dans le cas de la <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a>, chaque composant (<a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a>, <a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a>, <a class="el" href="struct_mapper.html" title="Generic structure to hold mapper. ">Mapper</a>) fonctionne en parallèle, ce qui implique une quantité importante de données à traiter. La plupart des émulateurs développés au début de l'an 2000 devait faire en sorte d'être optimisés au mieux pour ne pas être limités par le processeur de la machine. Ainsi, l'une des techniques utilisées était la <b>prédiction</b>, une méthode permettant de prédire l'usage de tels ou tels composants et ne l’exécuter seulement lorsque c'est nécessaire. Aujourd'hui, nos processeurs n'ont rien à envier à l'ancienne génération, ces problématiques ne sont donc plus de l'ordre du jour et les émulateurs peuvent se permettre d'être <b>précis (accurate)</b>. On entend par précis le fait d’exécuter les composants à chaque instant de l'émulation, ce qui rapproche du fonctionnement machine.</p>
<p>Dans notre cas, nous avons choisi de concevoir un <b>émulateur précis</b> puisque aujourd'hui la quasi totalité des ordinateurs sont capables de gérer un tel processus et parce que la prédiction nous aurais demandé un temps de développent bien plus élevé.</p>
<h3>Fonctionnalités des émulateurs</h3>
<p>Voici une liste non-exhaustive de fonctionnalités que l'on retrouve sur les émulateurs <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a> :</p>
<ul>
<li><b>Save</b> : permet de sauvegarder le contexte d'exécution de la machine pour reprendre la progression de son jeu plus tard</li>
<li><b>Movie/Tool-assisted speedrun</b> : permet de sauvegarder une série d'événement pouvant être re-exécutés plus tard</li>
<li><b>Pause/Resume</b> : stopper/reprendre l'exécution de son jeu</li>
<li><b>Speed x</b> : accélérer l'exécution de son jeu, pouvant être utile pendant des scènes de dialogues</li>
<li><b>Rescale</b> : agrandir l'affichage pour avoir un meilleur confort visuel</li>
<li><b>Configuration des touches claviers</b> : choisir ses touches claviers à associer aux contrôles de la <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a></li>
</ul>
<h2>Exigences</h2>
<ul>
<li>Se rapprocher au plus du fonctionnement hardware de la <a class="el" href="struct_n_e_s.html" title="Hold every component to emulate the Nintendo Entertainement System. ">NES</a> (émulation précise)</li>
<li>Développer quelques mappers (deux ou trois)</li>
<li>Avoir des performances graphiques fluides (NTSC - 60 FPS)</li>
<li>Interface de gestion (choix des ROMs, raccourcis clavier, paramètres graphiques)<ul>
<li>Pouvoir mettre à l'échelle l'affichage (proportionnel)</li>
<li>Pouvoir enregistrer le contexte d'exécution d'un jeu pour sauvegarder sa partie</li>
<li>Pouvoir mettre en pause le jeu</li>
</ul>
</li>
<li>(Optionnel) Développement de l'APU (moteur sonore)</li>
</ul>
<h2>Versions</h2>
<h3>V0</h3>
<ul>
<li>Émuler l'ensemble <a class="el" href="struct_c_p_u.html" title="Hold CPU&#39;s register and memory. ">CPU</a> et <a class="el" href="struct_p_p_u.html" title="Hold every variable needed to run PPU. ">PPU</a></li>
<li>Interagir avec le jeu via les touches du claviers</li>
<li>Chargement des ROMs via le terminal</li>
<li>Développement d'un seul mapper (NROM)</li>
</ul>
<h3>V1</h3>
<ul>
<li>Développement de plusieurs mappers (MMC1, MMC3 et/ou UROM)</li>
<li>Interface de gestion :<ul>
<li>Chargement des ROMs</li>
<li>Configuration des touches</li>
<li>Rescale de l'image</li>
<li>Chargement/Sauvegarde du contexte et pause </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
